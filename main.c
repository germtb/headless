// Headless skip

#include <assert.h>
#include <ctype.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "./tree-sitter-c/bindings/c/tree-sitter-c.h"
#include "./tree-sitter/lib/include/tree_sitter/api.h"

bool is_generated_file(const char *source_code) {
  return strstr(source_code, "// Generated by headless") != NULL;
}

bool is_c_file(const char *file_path) {
  size_t len = strlen(file_path);

  if (len < 2) {
    return false;
  }

  return (file_path[len - 2] == '.' && file_path[len - 1] == 'c');
}

const char *calculate_header_name(const char *file_path) {
  uint32_t start = 0;
  uint32_t end = 0;
  uint32_t index = 0;

  while (file_path[++index] != '\0') {
    if (file_path[index] == '/') {
      start = index + 1;
    }
  }

  end = index;

  uint32_t len = end - start;
  char *header_file_path = malloc(len + 1);

  for (uint32_t i = start; i < end; i++) {
    header_file_path[i - start] = file_path[i];
  }

  header_file_path[len - 1] = 'h';
  header_file_path[len] = '\0';

  return header_file_path;
}

char *calculateDefName(const char *file_path) {
  uint32_t start = 0;
  uint32_t end = 0;
  uint32_t index = 0;

  while (file_path[++index] != '\0') {
    if (file_path[index] == '/') {
      start = index + 1;
    }
  }

  end = index;

  uint32_t len = end - start + 4;
  char *def_name = malloc(len + 1 + 4);

  def_name[0] = '_';
  def_name[1] = '_';

  for (uint32_t i = start; i < end; i++) {
    def_name[i - start + 2] = toupper(file_path[i]);
  }

  def_name[len - 4] = '_';
  def_name[len - 3] = 'H';
  def_name[len - 2] = '_';
  def_name[len - 1] = '_';
  def_name[len] = '\0';

  return def_name;
}

char *get_node_as_str(TSNode node, const char *source_code) {
  uint32_t start_byte = ts_node_start_byte(node);
  uint32_t end_byte = ts_node_end_byte(node);
  uint32_t length = end_byte - start_byte;

  char *str = malloc(length + 1);
  memcpy(str, source_code + start_byte, length);
  str[length] = '\0';

  return str;
}

void print_node(FILE *file, TSNode node, const char *source_code) {
  uint32_t start_byte = ts_node_start_byte(node);
  uint32_t end_byte = ts_node_end_byte(node);
  fprintf(file, "%.*s", end_byte - start_byte, source_code + start_byte);
}

const char *read_file(const char *filename) {
  FILE *fp;
  char *src = NULL;

  fp = fopen(filename, "rw");

  if (fp == NULL) {
    return NULL;
  }

  fseek(fp, 0, SEEK_END);
  long size = ftell(fp);
  fseek(fp, 0, SEEK_SET);

  src = malloc(size * sizeof(char));
  fread(src, 1, size, fp);

  return src;
}

char *calculate_header_path(const char *file_path) {
  char *header_path = malloc(strlen(file_path) + 1);
  size_t len = strlen(file_path);

  for (uint32_t i = 0; i < len; i++) {
    header_path[i] = file_path[i];
  }

  header_path[len - 1] = 'h';
  return header_path;
}

void print_nodes(TSNode root_node, const char *source_code,
                 const char *header_name, FILE *header_file) {
  uint32_t child_count = ts_node_child_count(root_node);
  for (uint32_t i = 0; i < child_count; i++) {
    TSNode child = ts_node_child(root_node, i);
    const char *type = ts_node_type(child);

    if (strcmp(type, "function_definition") == 0) {
      uint32_t child_count = ts_node_child_count(child);
      bool is_static = false;

      for (uint32_t i = 0; i < child_count; i++) {
        TSNode node = ts_node_child(child, i);
        const char *type = ts_node_type(node);

        if (i == 0 && strcmp(type, "storage_class_specifier") == 0) {
          is_static = true;
          break;
        }

        if (strcmp(type, "compound_statement") == 0) {
          break;
        }

        print_node(header_file, node, source_code);

        if (i < child_count - 2) {
          fprintf(header_file, " ");
        }
      }

      if (!is_static) {
        fprintf(header_file, ";\n\n");
      }
    } else if (strcmp(type, "struct_specifier") == 0) {
      print_node(header_file, child, source_code);
      fprintf(header_file, ";\n\n");
    } else if (strcmp(type, "type_definition") == 0) {
      print_node(header_file, child, source_code);
      fprintf(header_file, "\n\n");
    } else if (strcmp(type, "enum_specifier") == 0) {
      print_node(header_file, child, source_code);
      fprintf(header_file, ";\n\n");
    } else if (strcmp(type, "preproc_include") == 0) {
      char *content = get_node_as_str(child, source_code);

      if (strstr(content, header_name)) {
        free(content);
        continue;
      }

      free(content);
      print_node(header_file, child, source_code);
      fprintf(header_file, "\n");
    } else if (strcmp(type, "preproc_ifdef") == 0) {
      print_nodes(child, source_code, header_name, header_file);
    } else if (strcmp(type, "preproc_def") == 0) {
      print_node(header_file, child, source_code);
    } else {
      // printf("Type: %s\n", type);
    }
  }
}

int main(int argv, char **argc) {

  if (argv != 2) {
    printf("Usage: %s <source_file>\n", argc[0]);
    return 1;
  }

  if (!is_c_file(argc[1])) {
    printf("Target %s is not a C file\n", argc[1]);
    return 0;
  }

  const char *file_path = argc[1];
  const char *source_code = read_file(file_path);
  const char *header_name = calculate_header_name(file_path);
  const char *header_path = calculate_header_path(file_path);
  const char *header_code = read_file(header_path);

  if (strstr(source_code, "// Headless skip")) {
    printf("Skipping %s\n", file_path);
    return 0;
  }

  if (header_code != NULL && !is_generated_file(header_code)) {
    fprintf(stderr, "There is an existing header which is not generated by "
                    "headless, will not override\n");
    return 0;
  }

  TSParser *parser = ts_parser_new();
  ts_parser_set_language(parser, tree_sitter_c());
  TSTree *tree =
      ts_parser_parse_string(parser, NULL, source_code, strlen(source_code));

  TSNode root_node = ts_tree_root_node(tree);

  char *def_name = calculateDefName(file_path);

  FILE *header_file = fopen(header_path, "w");

  fprintf(header_file, "// Generated by headless\n\n");
  fprintf(header_file, "#ifndef __HEADLESS__\n");
  fprintf(header_file, "#define __HEADLESS__\n\n");
  fprintf(header_file, "#endif\n\n");
  fprintf(header_file, "#ifndef %s\n", def_name);
  fprintf(header_file, "#define %s\n\n", def_name);

  print_nodes(root_node, source_code, header_name, header_file);

  fprintf(header_file, "#endif // %s\n", def_name);
  fclose(header_file);
  printf("Generated header for %s at %s\n", file_path, header_path);

  return 0;
}
